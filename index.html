
<!--  
▒█▀▀█ ▒█▀▀▀ ▀▄▒▄▀ ▒█▀▀▀█ ▒█░▒█ ▀█▀ ▒█▀▄▀█ ▒█░▒█ ▒█▀▀█ ░█▀▀█ 
▒█▄▄▀ ▒█▀▀▀ ░▒█░░ ░▀▀▀▄▄ ▒█▀▀█ ▒█░ ▒█▒█▒█ ▒█░▒█ ▒█▄▄▀ ▒█▄▄█ 
▒█░▒█ ▒█▄▄▄ ▄▀▒▀▄ ▒█▄▄▄█ ▒█░▒█ ▄█▄ ▒█░░▒█ ░▀▄▄▀ ▒█░▒█ ▒█░▒█ -->

<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII WebCam</title>
    <link rel="icon" type="image/x-icon" href="asset/ascii.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        :root {
            --line-height-ratio: 0.85;
        }

        body {
            font-family: 'Inter', sans-serif;
        }

        #ascii-output {
            line-height: var(--line-height-ratio);
            letter-spacing: -0.5px;
            background-color: transparent; 
            will-change: contents;
            transition: transform 0.5s ease-in-out, color 0.3s;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #4A5568; 
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366F1; 
            cursor: pointer;
            border: 3px solid #1A202C; 
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366F1; 
            cursor: pointer;
            border: 3px solid #1A202C; 
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4 transition-colors duration-300">

    <div class="w-full max-w-7xl mx-auto flex flex-col items-center">
        <header class="text-center mb-6">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-white tracking-tight">
                Live ASCII Camera V1.508
            </h1>
            <p class="text-gray-400 mt-2">Transform your reality into text-based art.</p>
        </header>

        <div class="w-full max-w-3xl mb-6 p-4 bg-gray-800/50 rounded-xl backdrop-blur-lg border border-gray-700 shadow-lg">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="flex flex-col gap-4">
                    <button id="start-camera" class="w-full px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75 transition-all transform hover:scale-105">
                        Start Camera
                    </button>
                    <div class="grid grid-cols-2 gap-4">
                        <div id="camera-toggle-group" class="flex items-center bg-gray-700 rounded-lg p-1">
                            <button id="front-camera-btn" class="flex-1 py-1.5 px-2 rounded-md text-sm font-medium flex items-center justify-center gap-1.5 transition-all" title="Normal Camera">
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" />
                                </svg>
                                <span>Normal</span>
                            </button>
                            <button id="back-camera-btn" class="flex-1 py-1.5 px-2 rounded-md text-sm font-medium flex items-center justify-center gap-1.5 transition-all" title="Flip Camera">
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                     <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21L3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" />
                                </svg>
                                <span>Flip</span>
                            </button>
                        </div>
                        <button id="fullscreen" title="Toggle Fullscreen" class="flex items-center justify-center gap-2 p-2 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors transform">
                            <span id="enter-fullscreen-icon"><svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" /></svg></span>
                            <span id="exit-fullscreen-icon" class="hidden"><svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 9L4.5 4.5M9 9V4.5M9 9H4.5m10.5 0L15 4.5m0 0V9m0-4.5h4.5m-4.5 10.5L15 20.25m0 0V15.75m0 4.5h4.5M9 15.75l-4.5 4.5m0-4.5H9" /></svg></span>
                            <span>Fullscreen</span>
                        </button>
                    </div>
                </div>
                <div class="flex flex-col gap-4">
                    <div class="flex justify-between items-center">
                         <label for="resolution-slider" class="font-medium text-gray-300">Preview Detail:</label>
                         <span id="resolution-value" class="text-sm font-mono bg-gray-700 px-2 py-1 rounded">200</span>
                    </div>
                    <input type="range" id="resolution-slider" min="90" max="300" value="200" class="w-full">
                    
                    <div class="flex justify-between items-center">
                        <label for="color-picker" class="font-medium text-gray-300">Text Color:</label>
                        <input type="color" id="color-picker" value="#34D399" class="w-10 h-10 rounded-md border-2 border-gray-600 cursor-pointer">
                    </div>
                     <div class="flex justify-between items-center">
                        <label for="timer-select" class="font-medium text-gray-300">Capture Timer:</label>
                        <select id="timer-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block w-auto p-2">
                            <option value="0">Off</option>
                            <option value="1">1s</option>
                            <option value="2">2s</option>
                            <option value="3">3s</option>
                            <option value="5">5s</option>
                            <option value="8">8s</option>
                            <option value="10">10s</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div id="output-container" class="relative w-full bg-black p-2 rounded-xl shadow-2xl border border-gray-700 overflow-hidden flex items-center justify-center min-h-[65vh] transition-colors">
             <pre id="ascii-output" class="w-full text-center font-mono" style="color: #34D399;">
                <span id="placeholder" class="text-gray-500 text-lg" style="font-size: 1rem;">open your cam first oke?</span>
            </pre>
            <div id="countdown-overlay" class="absolute inset-0 bg-black/70 flex items-center justify-center text-white text-9xl font-bold hidden z-10"></div>
            <button id="capture-image" title="Capture Image" class="absolute bottom-4 left-1/2 -translate-x-1/2 p-4 bg-black/50 text-white rounded-full hover:bg-black/75 backdrop-blur-sm transition-all transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-white/50 hidden">
                <svg class="w-8 h-8" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" />
                </svg>
            </button>
        </div>

        <p id="message" class="mt-4 text-gray-400"></p>
    </div>

    <video id="video" playsinline class="hidden"></video>
    <canvas id="canvas" class="hidden"></canvas>
    <canvas id="capture-canvas" class="hidden"></canvas>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const asciiOutput = document.getElementById('ascii-output');
        const outputContainer = document.getElementById('output-container');
        const startButton = document.getElementById('start-camera');
        const colorPicker = document.getElementById('color-picker');
        const messageEl = document.getElementById('message');
        const fullscreenButton = document.getElementById('fullscreen');
        const captureButton = document.getElementById('capture-image');
        const captureCanvas = document.getElementById('capture-canvas');
        const resolutionSlider = document.getElementById('resolution-slider');
        const resolutionValue = document.getElementById('resolution-value');
        const frontCamBtn = document.getElementById('front-camera-btn');
        const backCamBtn = document.getElementById('back-camera-btn');
        const timerSelect = document.getElementById('timer-select');
        const countdownOverlay = document.getElementById('countdown-overlay');

        const context = canvas.getContext('2d', { willReadFrequently: true });
        
        const density = 'Ñ@#W$9876543210?!abc;:+=-,._ ';

        let stream;
        let currentFacingMode = 'user';

        // --- Camera Toggle UI ---
        const updateCameraToggleUI = () => {
            const activeClasses = ['bg-gray-600', 'shadow', 'text-white'];
            const inactiveClasses = ['text-gray-400'];

            if (currentFacingMode === 'user') { // "Normal"
                frontCamBtn.classList.add(...activeClasses);
                frontCamBtn.classList.remove(...inactiveClasses);
                backCamBtn.classList.remove(...activeClasses);
                backCamBtn.classList.add(...inactiveClasses);
            } else { // "Flip"
                backCamBtn.classList.add(...activeClasses);
                backCamBtn.classList.remove(...inactiveClasses);
                frontCamBtn.classList.remove(...activeClasses);
                frontCamBtn.classList.add(...inactiveClasses);
            }
        };

        // --- Event Listeners ---
        startButton.addEventListener('click', async () => {
            if (stream && stream.active) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                startButton.textContent = 'Start Camera';
                startButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                startButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                captureButton.classList.add('hidden');
                messageEl.textContent = "Camera stopped.";
                asciiOutput.innerHTML = `<span id="placeholder" class="text-gray-500 text-lg" style="font-size: 1rem;">Your ASCII camera feed will appear here.</span>`;
            } else {
                await setupCamera();
            }
        });

        colorPicker.addEventListener('input', (e) => {
            asciiOutput.style.color = e.target.value;
        });
        
        resolutionSlider.addEventListener('input', (e) => {
            resolutionValue.textContent = e.target.value;
        });

        async function switchCamera(newMode) {
            if (currentFacingMode === newMode && stream && stream.active) return;
            currentFacingMode = newMode;
            updateCameraToggleUI();
            if (stream && stream.active) {
                stream.getTracks().forEach(track => track.stop());
                await setupCamera();
            }
        }
        frontCamBtn.addEventListener('click', () => switchCamera('user'));
        backCamBtn.addEventListener('click', () => switchCamera('environment'));

        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                outputContainer.requestFullscreen().catch(err => {
                    messageEl.textContent = `Error: ${err.message}`;
                });
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        });
        
        document.addEventListener('fullscreenchange', () => {
            const enterIcon = document.getElementById('enter-fullscreen-icon');
            const exitIcon = document.getElementById('exit-fullscreen-icon');
            if (document.fullscreenElement) {
                enterIcon.classList.add('hidden');
                exitIcon.classList.remove('hidden');
            } else {
                enterIcon.classList.remove('hidden');
                exitIcon.classList.add('hidden');
            }
        });
        
        // --- MODIFIED: HD Image Capture Function ---
        const performCapture = () => {
            if (!stream || !stream.active || video.videoHeight === 0) {
                messageEl.textContent = "Camera is not ready for capture.";
                return;
            }

            messageEl.textContent = "Processing HD capture...";

            // 1. Get HD dimensions from the actual video stream
            const hdWidth = video.videoWidth;
            const hdHeight = video.videoHeight;

            // 2. Use a temporary canvas to draw the current video frame in full resolution
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = hdWidth;
            tempCanvas.height = hdHeight;
            tempContext.drawImage(video, 0, 0, hdWidth, hdHeight);

            // 3. Generate a new, high-detail ASCII string for the capture
            //    Use the slider's value for capture resolution
            const captureAsciiWidth = parseInt(resolutionSlider.value, 10); 
            const aspectRatio = hdHeight / hdWidth;
            const asciiPixelAspect = 0.5; // ASCII characters are taller than they are wide.
            const captureAsciiHeight = Math.floor(captureAsciiWidth * aspectRatio * asciiPixelAspect);

            // 4. Scale the HD image down to the target ASCII dimensions for processing brightness
            const processingCanvas = document.createElement('canvas');
            const processingContext = processingCanvas.getContext('2d');
            processingCanvas.width = captureAsciiWidth;
            processingCanvas.height = captureAsciiHeight;
            processingContext.drawImage(tempCanvas, 0, 0, captureAsciiWidth, captureAsciiHeight);
            
            const imageData = processingContext.getImageData(0, 0, captureAsciiWidth, captureAsciiHeight);
            const data = imageData.data;
            let asciiText = '';
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                const densityIndex = Math.floor(brightness * (density.length - 1));
                const char = density[density.length - 1 - densityIndex];
                asciiText += char;
                if ((i / 4 + 1) % captureAsciiWidth === 0) {
                    asciiText += '\n';
                }
            }
            
            const lines = asciiText.split('\n').filter(line => line && line.trim() !== '');
            if (lines.length === 0) {
                messageEl.textContent = "Capture failed: could not generate ASCII art.";
                return;
            }

            // 5. Render this detailed ASCII string onto the final 'captureCanvas'
            // Define the fixed, target dimensions for the output image
            const targetWidth = 1920; 
            const targetHeight = 1080;
            
            const styles = window.getComputedStyle(asciiOutput);
            const bgColor = window.getComputedStyle(outputContainer).backgroundColor;
            const captureContext = captureCanvas.getContext('2d');

            // Calculate font size and line height based on target dimensions
            const initialFontSize = 8;
            captureContext.font = `${initialFontSize}px 'monospace'`; // Use a monospaced font for calculation
            
            const lineHeightRatio = 0.85; // Fixed line height
            const baseLineHeight = initialFontSize * lineHeightRatio;

            // Calculate the total pixel dimensions of the generated ASCII art at the base font size
            let maxLineWidth = 0;
            lines.forEach(line => {
                const metrics = captureContext.measureText(line);
                if (metrics.width > maxLineWidth) {
                    maxLineWidth = metrics.width;
                }
            });

            const asciiArtWidth = maxLineWidth;
            const asciiArtHeight = baseLineHeight * lines.length;
            
            // Calculate the scaling factor to fit the ASCII art to the target dimensions
            const scaleX = targetWidth / asciiArtWidth;
            const scaleY = targetHeight / asciiArtHeight;
            const scaleFactor = Math.min(scaleX, scaleY); // Use the smaller scale factor to fit
            
            const finalFontSize = initialFontSize * scaleFactor;
            const finalLineHeight = baseLineHeight * scaleFactor;

            // Re-integrate watermark logic for the HD capture
            const randomMessages = [":D Art in motion.", ":) Capture the moment.", "X) Create your reality.", "XD Pixels to patterns.", ":O Digital soul.", ":P The world in code.", ":Y Seen through the matrix.", ":3 Another reality captured.", ":> Text-based masterpiece.", ":| A moment in ASCII.", ":) Smile for me!", ":9 Converting photons to text.", ":O Is this real life?", ";D Fragment of time.", ";) Beyond the pixels."];
            const randomMessage = randomMessages[Math.floor(Math.random() * randomMessages.length)];
            const date = new Date();
            const dateText = date.toLocaleDateString('en-US', { month: 'short', day: '2-digit', year: 'numeric' }).toUpperCase().replace(/, /g, '-').replace(/ /g, '-');
            const line1Left = "LIVE ASCII CAMERA", line1Right = dateText, line2Left = "By Rexshimura", line2Right = randomMessage;
            
            // Calculate watermark font size and padding based on final font size
            const watermarkFontSize = Math.max(10, finalFontSize * 0.8); 
            const watermarkPadding = watermarkFontSize * 1.5;
            const watermarkLineHeight = watermarkFontSize * 1.2;
            const watermarkFont = `500 ${watermarkFontSize}px 'Inter', sans-serif`;
            const paddingFromEdge = 20;
            const watermarkBlockHeight = (watermarkLineHeight * 2) + (watermarkPadding * 2);
            
            // Final canvas dimensions are now fixed
            const canvasWidth = targetWidth;
            const canvasHeight = targetHeight;

            captureCanvas.width = canvasWidth;
            captureCanvas.height = canvasHeight;
            
            // 6. Draw everything to the capture canvas
            captureContext.fillStyle = bgColor;
            captureContext.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Draw the ASCII art scaled and centered
            const totalAsciiHeight = lines.length * finalLineHeight;
            const totalAsciiWidth = maxLineWidth * scaleFactor;
            const startX = (canvasWidth - totalAsciiWidth) / 2;
            const startY = (canvasHeight - totalAsciiHeight) / 2;

            captureContext.font = `${finalFontSize}px ${styles.fontFamily}`;
            captureContext.fillStyle = styles.color;
            captureContext.textBaseline = 'top';
            
            lines.forEach((line, index) => {
                let lineToDraw = (currentFacingMode === 'user') ? line.split('').reverse().join('') : line;
                let textWidth = captureContext.measureText(lineToDraw).width;
                let xPosition = startX + (totalAsciiWidth - textWidth) / 2; // Center each line horizontally
                captureContext.fillText(lineToDraw, xPosition, startY + index * finalLineHeight);
            });
            
            // Draw the watermark
            captureContext.font = watermarkFont;
            captureContext.globalAlpha = 0.7;
            const bottomY = canvasHeight - paddingFromEdge;

            captureContext.textBaseline = 'bottom';
            captureContext.textAlign = 'left';
            captureContext.fillText(line2Left, paddingFromEdge, bottomY);
            captureContext.fillText(line1Left, paddingFromEdge, bottomY - watermarkLineHeight);
            
            captureContext.textAlign = 'right';
            captureContext.fillText(line2Right, canvasWidth - paddingFromEdge, bottomY);
            captureContext.fillText(line1Right, canvasWidth - paddingFromEdge, bottomY - watermarkLineHeight);

            captureContext.globalAlpha = 1.0;

            // 7. Trigger download
            const link = document.createElement('a');
            link.download = `ascii-capture-HD-${new Date().toISOString().slice(0,19).replace('T','-').replace(/:/g,'-')}.png`;
            link.href = captureCanvas.toDataURL('image/png');
            link.click();
            
            messageEl.textContent = "HD Image captured!";
            setTimeout(() => { if(stream && stream.active) messageEl.textContent = "Camera is active!"; }, 3000);
        };

        captureButton.addEventListener('click', () => {
            if (!stream || !stream.active) {
                messageEl.textContent = "Start the camera to capture an image.";
                return;
            }

            const timerDuration = parseInt(timerSelect.value, 10);

            if (timerDuration === 0) {
                performCapture();
            } else {
                let countdown = timerDuration;
                countdownOverlay.textContent = countdown;
                countdownOverlay.classList.remove('hidden');
                captureButton.classList.add('hidden'); 

                const interval = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        countdownOverlay.textContent = countdown;
                    } else {
                        clearInterval(interval);
                        countdownOverlay.classList.add('hidden');
                        performCapture();
                        captureButton.classList.remove('hidden'); 
                    }
                }, 1000);
            }
        });

        // --- MODIFIED: Camera Setup Function ---
        const setupCamera = async () => {
            try {
                messageEl.textContent = "Requesting camera access...";
                const constraints = {
                    audio: false,
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        facingMode: currentFacingMode
                    }
                };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                video.srcObject = stream;
                video.play();
                
                asciiOutput.style.transform = (currentFacingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)';

                messageEl.textContent = "Camera is active!";
                startButton.textContent = 'Stop Camera';
                startButton.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                startButton.classList.add('bg-red-600', 'hover:bg-red-700');
                captureButton.classList.remove('hidden');
            } catch (err) {
                console.error("Error accessing camera: ", err);
                messageEl.textContent = `Could not access the ${currentFacingMode} camera with HD. It may not be available or resolution is not supported.`;
                if (currentFacingMode === 'environment') {
                    messageEl.textContent += " Trying front camera.";
                    switchCamera('user');
                } else {
                     stream = null;
                     startButton.textContent = 'Start Camera';
                     startButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                     startButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                     captureButton.classList.add('hidden');
                }
            }
        };

        video.addEventListener('play', () => {
            requestAnimationFrame(drawAsciiFrame);
        });

        const drawAsciiFrame = () => {
            if (video.paused || video.ended || !stream || !stream.active) return;
            if (video.videoHeight === 0) {
                requestAnimationFrame(drawAsciiFrame);
                return;
            }
            const asciiWidth = parseInt(resolutionSlider.value); 
            
            if (outputContainer.clientWidth > 0 && asciiWidth > 0) {
                const newFontSize = (outputContainer.clientWidth / asciiWidth) * 1.3;
                asciiOutput.style.fontSize = `${newFontSize}px`;
            }

            const aspectRatio = video.videoHeight / video.videoWidth;
            const asciiPixelAspect = 0.5; // ASCII characters are taller than they are wide.
            const asciiHeight = Math.floor(asciiWidth * aspectRatio * asciiPixelAspect);

            canvas.width = asciiWidth;
            canvas.height = asciiHeight;
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let asciiFrame = '';
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                const densityIndex = Math.floor(brightness * (density.length - 1));
                const char = density[density.length - 1 - densityIndex];
                
                asciiFrame += char;

                if ((i / 4 + 1) % canvas.width === 0) {
                    asciiFrame += '\n';
                }
            }
            asciiOutput.textContent = asciiFrame;
            requestAnimationFrame(drawAsciiFrame);
        };
        
        // Initialize with default slider values
        resolutionValue.textContent = resolutionSlider.value;
        updateCameraToggleUI();
    </script>
</body>
</html>