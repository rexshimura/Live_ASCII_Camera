<!-- 
██╗░░██╗███████╗██╗░░░░░██╗░░░░░░█████╗░
██║░░██║██╔════╝██║░░░░░██║░░░░░██╔══██╗
███████║█████╗░░██║░░░░░██║░░░░░██║░░██║
██╔══██║██╔══╝░░██║░░░░░██║░░░░░██║░░██║
██║░░██║███████╗███████╗███████╗╚█████╔╝
╚═╝░░╚═╝╚══════╝╚══════╝╚══════╝░╚════╝░ 
-->
<!-- 
█░█░█ █░█ ▄▀█ ▀█▀   █▀█   █░█   █░░ █▀█ █▀█ █▄▀ █ █▄░█   █░█ ▀█
▀▄▀▄▀ █▀█ █▀█ ░█░   █▀▄   █▄█   █▄▄ █▄█ █▄█ █░█ █ █░▀█   ▀▀█ ░▄ 
-->
<!-- 
▒█▀▀█ ▒█▀▀▀ ▀▄▒▄▀ ▒█▀▀▀█ ▒█░▒█ ▀█▀ ▒█▀▄▀█ ▒█░▒█ ▒█▀▀█ ░█▀▀█ 
▒█▄▄▀ ▒█▀▀▀ ░▒█░░ ░▀▀▀▄▄ ▒█▀▀█ ▒█░ ▒█▒█▒█ ▒█░▒█ ▒█▄▄▀ ▒█▄▄█ 
▒█░▒█ ▒█▄▄▄ ▄▀▒▀▄ ▒█▄▄▄█ ▒█░▒█ ▄█▄ ▒█░░▒█ ░▀▄▄▀ ▒█░▒█ ▒█░▒█ 
-->

<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced ASCII Camera</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
        }

        #ascii-output {
            line-height: 0.85;
            letter-spacing: -0.5px;
            background-color: transparent; 
            will-change: contents;
            transition: transform 0.5s ease-in-out, color 0.3s;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #4A5568; 
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366F1; 
            cursor: pointer;
            border: 3px solid #1A202C; 
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #6366F1; 
            cursor: pointer;
            border: 3px solid #1A202C; 
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4 transition-colors duration-300">

    <div class="w-full max-w-6xl mx-auto flex flex-col items-center">
        <!-- Header Section -->
        <header class="text-center mb-6">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-white tracking-tight">
                Live ASCII Camera
            </h1>
            <p class="text-gray-400 mt-2">Transform your reality into text-based art.</p>
        </header>

        <!-- Controls Section -->
        <div class="w-full max-w-3xl mb-6 p-4 bg-gray-800/50 rounded-xl backdrop-blur-lg border border-gray-700 shadow-lg">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Left Side: Main Actions -->
                <div class="flex flex-col gap-4">
                    <button id="start-camera" class="w-full px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75 transition-all transform hover:scale-105">
                        Start Camera
                    </button>
                    <div class="grid grid-cols-2 gap-4">
                        <!-- Renamed Radio-style Camera Toggle -->
                        <div id="camera-toggle-group" class="flex items-center bg-gray-700 rounded-lg p-1">
                            <button id="front-camera-btn" class="flex-1 py-1.5 px-2 rounded-md text-sm font-medium flex items-center justify-center gap-1.5 transition-all" title="Normal Camera">
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" />
                                </svg>
                                <span>Normal</span>
                            </button>
                            <button id="back-camera-btn" class="flex-1 py-1.5 px-2 rounded-md text-sm font-medium flex items-center justify-center gap-1.5 transition-all" title="Flip Camera">
                                <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                     <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21L3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" />
                                </svg>
                                <span>Flip</span>
                            </button>
                        </div>
                        <button id="fullscreen" title="Toggle Fullscreen" class="flex items-center justify-center gap-2 p-2 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors transform">
                            <span id="enter-fullscreen-icon"><svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" /></svg></span>
                            <span id="exit-fullscreen-icon" class="hidden"><svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 9L4.5 4.5M9 9V4.5M9 9H4.5m10.5 0L15 4.5m0 0V9m0-4.5h4.5m-4.5 10.5L15 20.25m0 0V15.75m0 4.5h4.5M9 15.75l-4.5 4.5m0-4.5H9" /></svg></span>
                            <span>Fullscreen</span>
                        </button>
                    </div>
                </div>
                <!-- Right Side: Settings -->
                <div class="flex flex-col gap-4">
                    <div class="flex justify-between items-center">
                         <label for="resolution-slider" class="font-medium text-gray-300">Resolution:</label>
                         <span id="resolution-value" class="text-sm font-mono bg-gray-700 px-2 py-1 rounded">120</span>
                    </div>
                    <input type="range" id="resolution-slider" min="50" max="120" value="120" class="w-full">
                    <div class="flex justify-between items-center">
                        <label for="color-picker" class="font-medium text-gray-300">Text Color:</label>
                        <input type="color" id="color-picker" value="#34D399" class="w-10 h-10 rounded-md border-2 border-gray-600 cursor-pointer">
                    </div>
                     <!-- Timer Selection Dropdown -->
                    <div class="flex justify-between items-center">
                        <label for="timer-select" class="font-medium text-gray-300">Capture Timer:</label>
                        <select id="timer-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block w-auto p-2">
                            <option value="0">Off</option>
                            <option value="1">1s</option>
                            <option value="2">2s</option>
                            <option value="3">3s</option>
                            <option value="5">5s</option>
                            <option value="8">8s</option>
                            <option value="10">10s</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <!-- ASCII Output Area -->
        <div id="output-container" class="relative w-full bg-black p-2 rounded-xl shadow-2xl border border-gray-700 overflow-hidden flex items-center justify-center min-h-[50vh] transition-colors">
             <pre id="ascii-output" class="w-full text-center font-mono" style="color: #34D399;">
                <span id="placeholder" class="text-gray-500 text-lg" style="font-size: 1rem;">open your cam first oke?</span>
            </pre>
            <!-- Countdown Overlay -->
            <div id="countdown-overlay" class="absolute inset-0 bg-black/70 flex items-center justify-center text-white text-9xl font-bold hidden z-10"></div>
            <!-- CAPTURE BUTTON OVERLAY -->
            <button id="capture-image" title="Capture Image" class="absolute bottom-4 left-1/2 -translate-x-1/2 p-4 bg-black/50 text-white rounded-full hover:bg-black/75 backdrop-blur-sm transition-all transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-white/50 hidden">
                <svg class="w-8 h-8" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" />
                </svg>
            </button>
        </div>

        <p id="message" class="mt-4 text-gray-400"></p>
    </div>

    <!-- Hidden elements -->
    <video id="video" playsinline class="hidden"></video>
    <canvas id="canvas" class="hidden"></canvas>
    <canvas id="capture-canvas" class="hidden"></canvas>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const asciiOutput = document.getElementById('ascii-output');
        const outputContainer = document.getElementById('output-container');
        const startButton = document.getElementById('start-camera');
        const colorPicker = document.getElementById('color-picker');
        const messageEl = document.getElementById('message');
        const fullscreenButton = document.getElementById('fullscreen');
        const captureButton = document.getElementById('capture-image');
        const captureCanvas = document.getElementById('capture-canvas');
        const resolutionSlider = document.getElementById('resolution-slider');
        const resolutionValue = document.getElementById('resolution-value');
        const frontCamBtn = document.getElementById('front-camera-btn');
        const backCamBtn = document.getElementById('back-camera-btn');
        const timerSelect = document.getElementById('timer-select');
        const countdownOverlay = document.getElementById('countdown-overlay');

        const context = canvas.getContext('2d', { willReadFrequently: true });
        
        const density = 'Ñ@#W$9876543210?!abc;:+=-,._ ';

        let stream;
        let currentFacingMode = 'user';

        // --- Camera Toggle UI ---
        const updateCameraToggleUI = () => {
            const activeClasses = ['bg-gray-600', 'shadow', 'text-white'];
            const inactiveClasses = ['text-gray-400'];

            if (currentFacingMode === 'user') { // "Normal"
                frontCamBtn.classList.add(...activeClasses);
                frontCamBtn.classList.remove(...inactiveClasses);
                backCamBtn.classList.remove(...activeClasses);
                backCamBtn.classList.add(...inactiveClasses);
            } else { // "Flip"
                backCamBtn.classList.add(...activeClasses);
                backCamBtn.classList.remove(...inactiveClasses);
                frontCamBtn.classList.remove(...activeClasses);
                frontCamBtn.classList.add(...inactiveClasses);
            }
        };

        // --- Event Listeners ---
        startButton.addEventListener('click', async () => {
            if (stream && stream.active) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                startButton.textContent = 'Start Camera';
                startButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                startButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                captureButton.classList.add('hidden');
                messageEl.textContent = "Camera stopped.";
                asciiOutput.innerHTML = `<span id="placeholder" class="text-gray-500 text-lg" style="font-size: 1rem;">Your ASCII camera feed will appear here.</span>`;
            } else {
                await setupCamera();
            }
        });

        colorPicker.addEventListener('input', (e) => {
            asciiOutput.style.color = e.target.value;
        });
        
        resolutionSlider.addEventListener('input', (e) => {
            resolutionValue.textContent = e.target.value;
        });

        async function switchCamera(newMode) {
            if (currentFacingMode === newMode && stream && stream.active) return;
            currentFacingMode = newMode;
            updateCameraToggleUI();
            if (stream && stream.active) {
                stream.getTracks().forEach(track => track.stop());
                await setupCamera();
            }
        }
        frontCamBtn.addEventListener('click', () => switchCamera('user'));
        backCamBtn.addEventListener('click', () => switchCamera('environment'));

        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                outputContainer.requestFullscreen().catch(err => {
                    messageEl.textContent = `Error: ${err.message}`;
                });
            } else if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        });
        
        document.addEventListener('fullscreenchange', () => {
            const enterIcon = document.getElementById('enter-fullscreen-icon');
            const exitIcon = document.getElementById('exit-fullscreen-icon');
            if (document.fullscreenElement) {
                enterIcon.classList.add('hidden');
                exitIcon.classList.remove('hidden');
            } else {
                enterIcon.classList.remove('hidden');
                exitIcon.classList.add('hidden');
            }
        });

        const performCapture = () => {
             const asciiText = asciiOutput.textContent;
            const lines = asciiText.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) {
                messageEl.textContent = "Nothing to capture.";
                return;
            }

            const styles = window.getComputedStyle(asciiOutput);
            const bgColor = window.getComputedStyle(outputContainer).backgroundColor;
            const fontSize = parseFloat(styles.fontSize);
            const captureContext = captureCanvas.getContext('2d');
            const font = `${fontSize}px ${styles.fontFamily}`;
            
            captureContext.font = font;
            const charWidth = captureContext.measureText('W').width; 
            const canvasWidth = charWidth * lines[0].length;
            const lineHeight = fontSize * 0.85; 
            const asciiArtHeight = lineHeight * lines.length;
            
            // --- NEW WATERMARK LOGIC ---

            // 1. Define watermark content
            const randomMessages = [
                ":D Art in motion.", ":) Capture the moment.", "X) Create your reality.", "XD Pixels to patterns.",
                ":O Digital soul.", ":P The world in code.", ":Y Seen through the matrix.", ":3 Another reality captured.",
                ":> Text-based masterpiece.", ":| A moment in ASCII.", ":) Smile for me!", ":9 Converting photons to text.",
                ":O Is this real life?", ";D Fragment of time.", ";) Beyond the pixels."
            ];
            const randomMessage = randomMessages[Math.floor(Math.random() * randomMessages.length)];
            const date = new Date();
            const dateText = date.toLocaleDateString('en-US', { month: 'short', day: '2-digit', year: 'numeric' }).toUpperCase().replace(/, /g, '-').replace(/ /g, '-');

            const line1Left = "LIVE ASCII CAMERA";
            const line1Right = dateText;
            const line2Left = "By Rexshimura";
            const line2Right = randomMessage;

            // 2. Define styles
            const watermarkFontSize = Math.max(8, fontSize * 0.7);
            const watermarkPadding = watermarkFontSize * 1.5;
            const watermarkLineHeight = watermarkFontSize * 1.2;
            const watermarkFont = `500 ${watermarkFontSize}px 'Inter', sans-serif`;
            const paddingFromEdge = 15;

            // 3. Calculate canvas height
            const watermarkBlockHeight = (watermarkLineHeight * 2) + (watermarkPadding * 2);
            const canvasHeight = asciiArtHeight + watermarkBlockHeight;

            captureCanvas.width = canvasWidth;
            captureCanvas.height = canvasHeight;
            
            // 4. Draw background and ASCII
            captureContext.fillStyle = bgColor;
            captureContext.fillRect(0, 0, canvasWidth, canvasHeight);
            
            captureContext.font = font;
            captureContext.fillStyle = styles.color;
            captureContext.textBaseline = 'top';
            
            lines.forEach((line, index) => {
                let lineToDraw = line;
                if (currentFacingMode === 'user' && asciiOutput.style.transform === 'scaleX(-1)') {
                     lineToDraw = line.split('').reverse().join('');
                }
                captureContext.fillText(lineToDraw, 0, index * lineHeight);
            });
            
            // 5. Draw the new watermark
            captureContext.font = watermarkFont;
            captureContext.globalAlpha = 0.7;
            
            const bottomY = canvasHeight - watermarkPadding;

            // Line 2 (bottom)
            captureContext.textBaseline = 'bottom';
            captureContext.textAlign = 'left';
            captureContext.fillText(line2Left, paddingFromEdge, bottomY);
            captureContext.textAlign = 'right';
            captureContext.fillText(line2Right, canvasWidth - paddingFromEdge, bottomY);
            
            // Line 1 (above line 2)
            captureContext.textBaseline = 'bottom';
            captureContext.textAlign = 'left';
            captureContext.fillText(line1Left, paddingFromEdge, bottomY - watermarkLineHeight);
            captureContext.textAlign = 'right';
            captureContext.fillText(line1Right, canvasWidth - paddingFromEdge, bottomY - watermarkLineHeight);

            captureContext.globalAlpha = 1.0;

            const link = document.createElement('a');
            link.download = `ascii-capture-${new Date().toISOString()}.png`;
            link.href = captureCanvas.toDataURL('image/png');
            link.click();
            
            messageEl.textContent = "Image captured!";
            setTimeout(() => { if(stream && stream.active) messageEl.textContent = "Camera is active!"; }, 3000);
        };

        captureButton.addEventListener('click', () => {
            if (!stream || !stream.active) {
                messageEl.textContent = "Start the camera to capture an image.";
                return;
            }

            const timerDuration = parseInt(timerSelect.value, 10);

            if (timerDuration === 0) {
                performCapture();
            } else {
                let countdown = timerDuration;
                countdownOverlay.textContent = countdown;
                countdownOverlay.classList.remove('hidden');
                captureButton.classList.add('hidden'); // Hide button during countdown

                const interval = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        countdownOverlay.textContent = countdown;
                    } else {
                        clearInterval(interval);
                        countdownOverlay.classList.add('hidden');
                        performCapture();
                        captureButton.classList.remove('hidden'); // Show button again
                    }
                }, 1000);
            }
        });


        const setupCamera = async () => {
            try {
                messageEl.textContent = "Requesting camera access...";
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: currentFacingMode },
                    audio: false 
                });
                
                video.srcObject = stream;
                video.play();
                
                // Flip the video preview if using the front camera
                asciiOutput.style.transform = (currentFacingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)';

                messageEl.textContent = "Camera is active!";
                startButton.textContent = 'Stop Camera';
                startButton.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                startButton.classList.add('bg-red-600', 'hover:bg-red-700');
                captureButton.classList.remove('hidden');
            } catch (err) {
                console.error("Error accessing camera: ", err);
                messageEl.textContent = `Could not access the ${currentFacingMode} camera. It may not be available.`;
                if (currentFacingMode === 'environment') {
                    switchCamera('user'); // Fallback to front camera
                }
            }
        };

        video.addEventListener('play', () => {
            requestAnimationFrame(drawAsciiFrame);
        });

        const drawAsciiFrame = () => {
            if (video.paused || video.ended || !stream || !stream.active) return;
            // Ensure video metadata is loaded
            if (video.videoHeight === 0) {
                requestAnimationFrame(drawAsciiFrame);
                return;
            }
            const asciiWidth = parseInt(resolutionSlider.value); 
            
            // --- DYNAMIC FONT SIZE CALCULATION ---
            if (outputContainer.clientWidth > 0 && asciiWidth > 0) {
                // Adjust font size based on container width and character count to maintain scale
                const newFontSize = (outputContainer.clientWidth / asciiWidth) * 0.95; // 0.95 factor to prevent line wrapping
                asciiOutput.style.fontSize = `${newFontSize}px`;
            }

            const aspectRatio = video.videoHeight / video.videoWidth;
            const asciiHeight = Math.floor(asciiWidth * aspectRatio * 0.5); // 0.5 factor for character aspect ratio

            canvas.width = asciiWidth;
            canvas.height = asciiHeight;
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let asciiFrame = '';
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                
                const densityIndex = Math.floor(brightness * (density.length - 1));
                const char = density[density.length - 1 - densityIndex];
                
                asciiFrame += char;

                if ((i / 4 + 1) % canvas.width === 0) {
                    asciiFrame += '\n';
                }
            }
            asciiOutput.textContent = asciiFrame;
            requestAnimationFrame(drawAsciiFrame);
        };
        
        // Initial call on page load
        updateCameraToggleUI();

    </script>
</body>
</html>

